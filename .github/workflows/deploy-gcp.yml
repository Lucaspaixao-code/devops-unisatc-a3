name: Deploy to Google Cloud

on:
  workflow_dispatch:
  push:
    branches:
      - main

env:
  TF_WORKING_DIR: 'terraform'
  # Segredos do GitHub
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: ${{ secrets.GCP_REGION }}
  TF_STATE_BUCKET: 'top-opus-479304-m3-terraform-state'
  
  # Variáveis para o Terraform (Sobrescrevem o terraform.tfvars)
  TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
  TF_VAR_region: ${{ secrets.GCP_REGION }}
  TF_VAR_docker_image: "lucaspaixao0/devops-strap/devops-unisatc-a3:latest"

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      # 1. Checkout do código
      - name: Checkout
        uses: actions/checkout@v4

      # 2. Autenticação no Google Cloud
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      # 3. Configurar Google Cloud SDK
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      # 4. Ativar APIs Necessárias (Compute, Container, Resource Manager)
      - name: Enable Google Cloud APIs
        run: |
          gcloud services enable compute.googleapis.com container.googleapis.com cloudresourcemanager.googleapis.com --project=${{ env.GCP_PROJECT_ID }}

      # 5. Criar Bucket de Estado (se não existir)
      - name: Ensure Terraform State Bucket exists
        run: |
          if ! gcloud storage buckets describe gs://${{ env.TF_STATE_BUCKET }} > /dev/null 2>&1; then
            echo "Criando bucket de estado..."
            gcloud storage buckets create gs://${{ env.TF_STATE_BUCKET }} --project=${{ env.GCP_PROJECT_ID }} --location=${{ env.GCP_REGION }} --uniform-bucket-level-access
          else
            echo "Bucket já existe."
          fi

      # 6. Instalar Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      # 7. Terraform Init e Apply
      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init
          terraform apply -auto-approve -input=false

      # 8. Obter Detalhes do Cluster (Nome e Localização)
      # ATENÇÃO: Isto requer que tenhas adicionado o output "kubernetes_cluster_location" no outputs.tf
      - name: Get Cluster Details
        working-directory: ${{ env.TF_WORKING_DIR }}
        id: tf-output
        run: |
          CLUSTER_NAME=$(terraform output -raw kubernetes_cluster_name)
          CLUSTER_LOCATION=$(terraform output -raw kubernetes_cluster_location)
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "cluster_location=$CLUSTER_LOCATION" >> $GITHUB_OUTPUT

      # 9. Debug (Verificar se o cluster aparece na lista)
      - name: Debug Cluster Info
        run: |
          echo "Procurando cluster: ${{ steps.tf-output.outputs.cluster_name }} em ${{ steps.tf-output.outputs.cluster_location }}"
          gcloud container clusters list --project=${{ env.GCP_PROJECT_ID }}

      # 10. Conectar ao Cluster GKE (Com localização exata)
      - name: Get GKE Credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ steps.tf-output.outputs.cluster_name }}
          location: ${{ steps.tf-output.outputs.cluster_location }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      # 11. Deploy da Aplicação (Deployment + Service)
      - name: Deploy to GKE
        run: |
          export DOCKER_IMAGE="${{ env.TF_VAR_docker_image }}"
          
          # 1. Aplica o Deployment (atualiza imagem do container)
          # O comando envsubst substitui apenas a variável $DOCKER_IMAGE no yaml
          envsubst '$DOCKER_IMAGE' < k8s/deployment.yaml | kubectl apply -f -
          
          # 2. Aplica o Service (Cria o LoadBalancer / IP Público)
          kubectl apply -f k8s/service.yaml

      # 12. Obter URL da Aplicação
      - name: Get Application URL
        run: |
          echo "A aguardar pelo IP Externo (isto pode demorar 1-2 minutos)..."
          # Tenta obter o IP externo durante 5 minutos (30 x 10s)
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get service app-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "✅ Aplicação disponível em: http://$EXTERNAL_IP"
              echo "URL=http://$EXTERNAL_IP" >> $GITHUB_ENV
              break
            fi
            echo "A aguardar IP... (tentativa $i/30)"
            sleep 10
          done

      # 13. [NOVO] Diagnóstico de Erros (Mostra Logs se algo falhar)
      # Este passo corre sempre, mesmo que os anteriores tenham sucesso, para veres os logs
      - name: Debug Application Logs
        if: always()
        run: |
          echo "=== Estado dos Pods ==="
          kubectl get pods -o wide
          
          echo "=== Descrição do Serviço ==="
          kubectl describe service app-service
          
          echo "=== Logs da Aplicação (Últimas 50 linhas) ==="
          # Tenta pegar logs de todos os pods com a label app=app
          kubectl logs -l app=app --tail=50 --all-containers=true || echo "Não foi possível obter logs (os pods podem não estar a rodar)"